# generator_maker.py - Solu»õia 8: Frequency Mapping Compression

from collections import Counter

def creeaza_generator_freq(sir_original, nume_fisier="generator_sir.py"):
    """
    AnalizeazƒÉ un »ôir »ôi genereazƒÉ un script Python care √Æl regenereazƒÉ
    folosind frequency mapping compression
    
    Args:
        sir_original: »ôirul de caractere (poate fi foarte lung)
        nume_fisier: numele scriptului generat (default: generator_sir.py)
    """
    
    print("="*70)
    print("üîç ANALIZEZ »òIRUL...")
    print("="*70 + "\n")
    
    # PASUL 1: CreeazƒÉ alfabetul (caractere unice sortate)
    caractere_unice = ''.join(sorted(set(sir_original)))
    indici = [caractere_unice.index(c) for c in sir_original]
    
    print(f"üìä Informa»õii de bazƒÉ:")
    print(f"   Lungime »ôir: {len(sir_original):,} caractere")
    print(f"   Caractere unice: {len(caractere_unice)}")
    print(f"   Alfabet: {caractere_unice[:50]}{'...' if len(caractere_unice) > 50 else ''}")
    print()
    
    # PASUL 2: AnalizeazƒÉ frecven»õa indicilor
    freq = Counter(indici)
    print(f"üìà Top 15 indici cei mai frecven»õi:")
    for idx, count in freq.most_common(15):
        procent = count / len(indici) * 100
        print(f"   Index {idx:3d} ('{caractere_unice[idx]}'): {count:5,} apari»õii ({procent:5.2f}%)")
    print()
    
    # PASUL 3: CreeazƒÉ maparea pentru cei mai frecven»õi indici
    # Folosim a-z (26) + A-Z (26) = 52 simboluri pentru cei mai frecven»õi
    top_freq = [idx for idx, _ in freq.most_common(52)]
    
    simboluri = []
    simboluri.extend([chr(97 + i) for i in range(26)])  # a-z
    simboluri.extend([chr(65 + i) for i in range(26)])  # A-Z
    
    mapping = {idx: simboluri[i] for i, idx in enumerate(top_freq)}
    reverse_map = {v: k for k, v in mapping.items()}
    
    # CalculeazƒÉ acoperirea
    count_top52 = sum(count for idx, count in freq.items() if idx in mapping)
    acoperire = count_top52 / len(indici) * 100
    
    print(f"üó∫Ô∏è  Mapare creatƒÉ:")
    print(f"   Indici mapa»õi: {len(mapping)} (cei mai frecven»õi)")
    print(f"   Acoperire: {acoperire:.1f}% din toate datele")
    print(f"   Simboluri folosite: a-z, A-Z")
    print()
    
    # PASUL 4: ComprimƒÉ datele
    compressed_parts = []
    for idx in indici:
        if idx in mapping:
            # Index frecvent -> literƒÉ simplƒÉ (1 char)
            compressed_parts.append(mapping[idx])
        else:
            # Index rar -> format _numƒÉr_
            compressed_parts.append(f"_{idx}_")
    
    compressed_str = ''.join(compressed_parts)
    
    # PASUL 5: CalculeazƒÉ statistici
    original_size = len(str(indici))  # lungimea ca listƒÉ Python
    compressed_size = len(compressed_str)
    economie = (1 - compressed_size / original_size) * 100
    
    print(f"üíæ REZULTATE COMPRESIE:")
    print(f"   Lungime originalƒÉ (listƒÉ Python): {original_size:,} caractere")
    print(f"   Lungime comprimatƒÉ (string): {compressed_size:,} caractere")
    print(f"   Economie: {economie:.1f}%")
    print()
    
    if economie > 55:
        print(f"   ‚úÖ EXCELENT! Compresie foarte eficientƒÉ")
    elif economie > 35:
        print(f"   üëç BUN! Compresie decentƒÉ")
    else:
        print(f"   ‚ö†Ô∏è  Compresie slabƒÉ - »ôirul e foarte uniform")
    print()
    
    # PASUL 6: GenereazƒÉ scriptul Python
    cod_generat = f'''"""
Generator de »ôir cu Frequency Mapping Compression
Generat automat de generator_maker.py

Statistici:
- Lungime »ôir original: {len(sir_original):,} caractere
- Caractere unice: {len(caractere_unice)}
- Economie: {economie:.1f}%
- Acoperire top-52: {acoperire:.1f}%
"""

def genereaza_sir():
    """
    RegenereazƒÉ »ôirul original din date comprimate
    
    Returns:
        str: »òirul original complet
    """
    
    # Alfabetul (caracterele unice sortate)
    alfabet = "{caractere_unice}"
    
    # Mapare inversƒÉ: literƒÉ simplƒÉ -> index √Æn alfabet
    # a-z, A-Z mapeazƒÉ cei mai frecven»õi 52 indici
    freq_map = {reverse_map}
    
    # Date comprimate
    # - Litere simple (a-z, A-Z) = indici frecven»õi
    # - Format _N_ = indici rari
    data = """{compressed_str}"""
    
    # Decodare: converte»ôte string comprimate √Ænapoi la indici
    indici = []
    i = 0
    while i < len(data):
        if data[i] == '_':
            # Format _numƒÉr_ pentru indici rari
            j = i + 1
            while j < len(data) and data[j] != '_':
                j += 1
            
            num_str = data[i+1:j]
            if num_str:  # verificƒÉ cƒÉ nu e gol
                indici.append(int(num_str))
            
            i = j + 1  # sari peste al doilea underscore
        else:
            # LiterƒÉ simplƒÉ = index frecvent
            if data[i] in freq_map:
                indici.append(freq_map[data[i]])
            i += 1
    
    # Reconstruie»ôte »ôirul din alfabet + indici
    return ''.join(alfabet[idx] for idx in indici)


def verifica_sir(sir_asteptat=None):
    """
    VerificƒÉ dacƒÉ »ôirul generat este corect
    
    Args:
        sir_asteptat: »ôirul original pentru compara»õie (op»õional)
    
    Returns:
        bool sau str: True/False dacƒÉ sir_asteptat e dat, altfel »ôirul generat
    """
    sir_generat = genereaza_sir()
    
    print(f"Lungime »ôir generat: {{len(sir_generat):,}}")
    print(f"Primele 100 caractere: {{sir_generat[:100]}}")
    
    if sir_asteptat:
        match = sir_generat == sir_asteptat
        print(f"Match cu originalul: {{match}}")
        if not match:
            # GƒÉse»ôte prima diferen»õƒÉ
            for i, (a, b) in enumerate(zip(sir_generat, sir_asteptat)):
                if a != b:
                    print(f"Prima diferen»õƒÉ la pozi»õia {{i}}: '{{a}}' vs '{{b}}'")
                    break
        return match
    
    return sir_generat


def info():
    """Afi»ôeazƒÉ informa»õii despre compresie"""
    print("="*60)
    print("üìä INFORMA»öII COMPRESIE")
    print("="*60)
    print(f"Lungime »ôir original: {len(sir_original):,} caractere")
    print(f"Caractere unice √Æn alfabet: {len(caractere_unice)}")
    print(f"Indici mapa»õi (top frecven»õi): {{len(freq_map)}}")
    print(f"Acoperire top-52: {acoperire:.1f}%")
    print(f"Dimensiune date comprimate: {len(compressed_str):,} caractere")
    print(f"Economie vs listƒÉ Python: {economie:.1f}%")
    print("="*60)


if __name__ == "__main__":
    print("="*60)
    print("üöÄ GENERATOR DE »òIR")
    print("="*60)
    print()
    
    sir = genereaza_sir()
    print(f"‚úÖ »òir generat cu succes!")
    print(f"   Lungime: {{len(sir):,}} caractere")
    print(f"   Primele 100 caractere: {{sir[:100]}}")
    print()
    
    info()
'''
    
    # PASUL 7: SalveazƒÉ scriptul generat
    with open(nume_fisier, 'w', encoding='utf-8') as f:
        f.write(cod_generat)
    
    print("="*70)
    print(f"‚úÖ SCRIPT GENERAT: {nume_fisier}")
    print("="*70)
    print(f"\nüìù UrmƒÉtorii pa»ôi:")
    print(f"   1. RuleazƒÉ direct: python {nume_fisier}")
    print(f"   2. Sau importƒÉ: from {nume_fisier[:-3]} import genereaza_sir")
    print(f"   3. Folose»ôte: sir = genereaza_sir()")
    print()


def estimeaza_compresie(sir_original):
    """
    EstimeazƒÉ economia fƒÉrƒÉ a genera scriptul (analizƒÉ rapidƒÉ)
    
    Args:
        sir_original: »ôirul de analizat
    
    Returns:
        float: procentul de economie estimat
    """
    caractere_unice = ''.join(sorted(set(sir_original)))
    indici = [caractere_unice.index(c) for c in sir_original]
    
    freq = Counter(indici)
    top_52 = [idx for idx, _ in freq.most_common(52)]
    
    # CalculeazƒÉ acoperire
    count_top52 = sum(count for idx, count in freq.items() if idx in top_52)
    acoperire = count_top52 / len(indici) * 100
    
    # EstimeazƒÉ dimensiuni
    lungime_lista = len(str(indici))
    
    chars_frecventi = int(len(indici) * (acoperire/100) * 1)
    chars_rari = int(len(indici) * ((100-acoperire)/100) * 4)
    total_comprimate = chars_frecventi + chars_rari
    
    economie = (1 - total_comprimate / lungime_lista) * 100
    
    print(f"üìä ESTIMARE RAPIDƒÇ:")
    print(f"   Lungime »ôir: {len(sir_original):,}")
    print(f"   Caractere unice: {len(caractere_unice)}")
    print(f"   Top 52 acoperƒÉ: {acoperire:.1f}% din date")
    print(f"   ListƒÉ Python: {lungime_lista:,} caractere")
    print(f"   Estimat comprimate: {total_comprimate:,} caractere")
    print(f"   Economie estimatƒÉ: {economie:.1f}%")
    
    return economie


# ============================================
# EXEMPLU DE UTILIZARE
# ============================================

if __name__ == "__main__":
    print("\n")
    print("="*70)
    print("üéØ GENERATOR DE GENERATOARE - Frequency Mapping Compression")
    print("="*70)
    print("\n")
    
    # Exemplu cu »ôir scurt
    sir_exemplu = "12xaebcad92bdas0hdlopm2963bgdjkewpmadgrizndunsohvsjibsjxoj"
    
    print(f"Exemplu cu »ôir scurt ({len(sir_exemplu)} caractere):\n")
    creeaza_generator_freq(sir_exemplu, "generator_sir.py")
    
    print("\n" + "="*70)
    print("üí° PENTRU »òIRUL TƒÇU DE 30,000 CARACTERE:")
    print("="*70)
    print("""
# VariantƒÉ 1: »òir direct √Æn cod
sir_meu = "»ôirul_tƒÉu_complet_de_30000_caractere..."
creeaza_generator_freq(sir_meu, "generator_final.py")

# VariantƒÉ 2: Citire din fi»ôier
with open('sir_30000.txt', 'r', encoding='utf-8') as f:
    sir_lung = f.read()
creeaza_generator_freq(sir_lung, "generator_final.py")

# VariantƒÉ 3: Doar estimare (fƒÉrƒÉ generare)
estimeaza_compresie(sir_lung)
    """)