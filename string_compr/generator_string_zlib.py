"""
String generator with zlib compression (DEFLATE algorithm)
Auto-generated by generator_maker_zlib.py

Compression statistics:
- Original string length: 6,000 characters (6,000 bytes)
- Compressed with zlib: 4,525 bytes
- Savings: 24.6%
- Compression level: 9 (maximum)

zlib uses the DEFLATE algorithm which combines:
- LZ77: Detects repeated sequences
- Huffman coding: Optimal symbol encoding
"""

import zlib
import base64


# Data compressed with zlib (level 9) and encoded in base64
# Base64 is necessary to store binary data as string in Python code
COMPRESSED_DATA = """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"""

# Statistics (for info() function)
ORIGINAL_LENGTH = 6000
ORIGINAL_BYTES = 6000
COMPRESSED_SIZE = 4525
BASE64_SIZE = 6036
COMPRESSION_RATIO = 75.4
SAVINGS = 24.6


def generate_string():
    """
    Regenerates the original string from zlib compressed data
    
    Returns:
        str: The complete original string, decompressed
    """
    
    # Step 1: Decode from base64 to bytes
    compressed_bytes = base64.b64decode(COMPRESSED_DATA)
    
    # Step 2: Decompress with zlib
    decompressed_bytes = zlib.decompress(compressed_bytes)
    
    # Step 3: Decode from bytes to UTF-8 string
    original_string = decompressed_bytes.decode('utf-8')
    
    return original_string


def info():
    """Display compression information"""
    print("="*60)
    print("ZLIB COMPRESSION INFO")
    print("="*60)
    print(f"Original string length: {ORIGINAL_LENGTH:,} characters")
    print(f"Original size: {ORIGINAL_BYTES:,} bytes")
    print(f"Compressed size: {COMPRESSED_SIZE:,} bytes")
    print(f"Base64 size: {BASE64_SIZE:,} bytes")
    print(f"Compression ratio: {COMPRESSION_RATIO}%")
    print(f"Savings: {SAVINGS}%")
    print(f"zlib compression level: 9 (maximum)")
    print("="*60)


def verify_string(expected_string=None):
    """
    Verifies if generated string is correct
    
    Args:
        expected_string: original string for comparison (optional)
    
    Returns:
        bool or str: True/False if expected_string given, otherwise generated string
    """
    generated = generate_string()
    
    print(f"Generated string length: {len(generated):,}")
    print(f"First 100 characters: {generated[:100]}")
    
    if expected_string:
        match = generated == expected_string
        print(f"Match with original: {match}")
        
        if not match:
            print(f"ERROR: String does not match!")
            # Find first difference
            min_len = min(len(generated), len(expected_string))
            for i in range(min_len):
                if generated[i] != expected_string[i]:
                    print(f"First difference at position {i}:")
                    print(f"  Generated:  '{generated[i]}'")
                    print(f"  Expected: '{expected_string[i]}'")
                    break
            
            if len(generated) != len(expected_string):
                print(f"Different lengths: {len(generated)} vs {len(expected_string)}")
        
        return match
    
    return generated


if __name__ == "__main__":
    print("="*60)
    print("STRING GENERATOR (ZLIB COMPRESSION)")
    print("="*60)
    print()
    
    s = generate_string()
    print(f"String generated successfully!")
    print(f"   Length: {len(s):,} characters")
    print()
    print("="*60)
    print("COMPLETE STRING:")
    print("="*60)
    print(s)
    print()
    print("="*60)
    print(f"First 100 characters: {s[:100]}")
    print(f"Last 100 characters: {s[-100:]}")
    print()
    
    info()
